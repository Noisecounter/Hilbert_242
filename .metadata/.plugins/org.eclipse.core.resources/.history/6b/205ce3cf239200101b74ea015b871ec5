#include "platform.h"
#include "sleep.h"
#include "xgpio.h"
#include "xil_exception.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xscugic.h"
#include <stdio.h>
#include <xil_types.h>

// XGpio_Config *gpio_config;
XGpio gpio;

u32 baudrate = 115200;
u16 optionUart;
u8 Tx[] = "Hello SNM\n\r";
static volatile u32 gpio_read_I, gpio_read_Q;
static volatile u32 intCounter, IntIDFull;

static XScuGic InterruptController;
static XScuGic_Config *GicConfig;

void ExtIrq_Handler(void *InstancePtr) {
  intCounter++;
  // IntIDFull = XScuGic_CPUReadReg(&InterruptController,
  // XSCUGIC_INT_ACK_OFFSET); XScuGic_CPUWriteReg(&InterruptController,
  // XSCUGIC_EOI_OFFSET, IntIDFull);
}

int SetUpInterruptSystem(XScuGic *XScuGicInstancePtr) {
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                               (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                               XScuGicInstancePtr);
  Xil_ExceptionEnable();
  xil_printf("Setup of ExceptionRegHandler done\r\n");
  return XST_SUCCESS;
}

int interrupt_init() {
  int Status;

  GicConfig = XScuGic_LookupConfig(&InterruptController);
  if (NULL == GicConfig) {
    return XST_FAILURE;
  }

  Status = XScuGic_CfgInitialize(&InterruptController, GicConfig,
                                 GicConfig->CpuBaseAddress);
  if (Status != XST_SUCCESS) {
    return XST_FAILURE;
  }

  Status = SetUpInterruptSystem(&InterruptController);
  if (Status != XST_SUCCESS) {
    return XST_FAILURE;
  }

  Status = XScuGic_Connect(&InterruptController, 61,
                           (Xil_ExceptionHandler)ExtIrq_Handler, (void *)NULL);
  if (Status != XST_SUCCESS) {
    return XST_FAILURE;
  }

  XScuGic_SetPriorityTriggerType(&InterruptController, 61, 0xA0 /*priority*/,
                                 0x03 /*rising edge*/);

  XScuGic_Enable(&InterruptController, 61);
  xil_printf("XScuGic has been enabled with status:  %d\r\n", Status);
  return XST_SUCCESS;
}

void gpio_init() {
    int Status;

    // Create the configuration structure (your original approach was mostly correct)
    static XGpio_Config gpio_config = {
        .BaseAddress = XPAR_AXI_GPIO_0_BASEADDR,
        .InterruptPresent = 0,
        .IsDual = 1
    };

    // Initialize the GPIO driver
    Status = XGpio_CfgInitialize(&gpio, &gpio_config, gpio_config.BaseAddress);
    if (Status != XST_SUCCESS) {
        xil_printf("GPIO initialization failed: %d\r\n", Status);
        return;
    }

    // Set both channels as inputs
    XGpio_SetDataDirection(&gpio, 1, 0xFFFFFFFF);
    XGpio_SetDataDirection(&gpio, 2, 0xFFFFFFFF);

    xil_printf("GPIO initialized successfully\r\n");
}


int main() {
    init_platform();
    gpio_init();
    interrupt_init();

    while (1) {

    	if(intCounter >= 50000)
    	{
    		gpio_read_I = XGpio_DiscreteRead(&gpio, 1);
    		gpio_read_Q = XGpio_DiscreteRead(&gpio, 2);
    		xil_printf("intCounter: %0d\n\r",intCounter);
    		xil_printf("I: %0d\n\r", gpio_read_I);
    		xil_printf("Q: %0d\n\r", gpio_read_Q);
    		intCounter = 0;
    	}
        //usleep(100000);
        //usleep(100000);
    }
    cleanup_platform();
    return 0;
}
